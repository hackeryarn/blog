#+TITLE: Appreciate your Constraints
#+DATE: 2019-08-01
#+DRAFT: true
#+TAGS: guide thoughts

Many engineers want to measure the quality and effectiveness of their work. They
turn to code coverage, burn down charts, and yearly goals, with the best
intention.

The metrics they gather provide quantitative data about how much work got done
and if what was planned got delivered, but they fail to tie the work to the
outcome. What good are 1,000 lines of code if the user never uses the
feature? These metrics distract from the two question every professional
should ask:

Did my work deliver measurable changes?

Did I stay within the constraints?

Everyone is familiar with the concept of measurable results. Others have written
and talked extensively on how to measure the right thing. <provide links>

But the second question, about constraints, may come as a surprise. As
engineers we have an averssion to constraints. In reality, however, it's not the
engineer that finds the best new tool that's viewed as an expert, it's the
engineer that gets amazing results with what's right in front of him.

As we dive down the rabbit hole of new tools in search of perfection -- timeline
double, bugs get introduced, and the whole project comes to a screeching halt
because of the mountain of tech debt we built up.

The expert engineer, on the other hand, keeps the introductions of new tools
small. He doesn't pull in a library for left pad because he knows how to write
that code quickly. His scope for new bugs is small so even if he introduces one
he can quickly find and fix it, in his own code. 

OK, most of the time the search for new tools doesn't get that bad, and the expert
engineer is only a fable. But the price of searching for perfect is very real,
and we should strive to be more like the expert engineer. 

In this article I want to cover the constraints I had to deal with in my
career and the techniques I found to dealing with them.
** Not Enough Time
Whether a bug came up, an outage happened, or we just underestimated a work, we
constantly come up against time constraints. It's the nature of the job when
working in a domain with a lot of complexity. 

The easy solution is push back the feature. We can finish it at the beginning of
next sprint because we work in small increments... Or at least we should. In my
experience, time constraints rarely become an issue if the tasks are kept small.
No one gets upset if features are delivered at the end of each iteration.

Time constraints become an issue when we take on too much work at once. When the
timeline is up and we have nothing to show, is a terrible spot to find
ourselves. We might have been one bug away from delivering the features, but
that doesn't matter if the stake holders get nothing.

To prevent this situation, you have to break the all or nothing mentality. When
you realize the task you're working on is too much at once, stop. Reevaluate
what the requirement are, even go back to the stakeholders.

Figure out the small chunk of work that will bring some value. Pareto principle
states that 20% of the work holds 80% of the value. When features bloat, it's up
to you to figure out the 20% that will deliver 80% of the value. Then you can
revisit the other 80% later, if it's still needed.
** Missing or Changing Requirements
Before you can be effective you need to have clarity of the expectations. To get
that clarity you need to ask questions. Your question will result in three
possible outcomes.

If the feature is high priority, you will get to have the conversation to need
and gain clarity. This will let you start work with a better idea of what's
needed and minimum down time.

A much worse outcome, but all too possible, is that you can't get anyone to look
at the feature. When this happens you should question the priorities. If it's
not a high enough priority to define well, it shouldn't be a high enough
priority for you to work on. The work is endless, your time isn't.

The third options, and the one I find most enjoyable, is when the feature is
high priority but the users and stakeholders aren't sure what they want. You get
the chance to create low fidelity prototypes, or just sketch out ideas. You also
gain the opportunity to learn a ton about the users of your application. Use this
round of rapid feedback a learning opportunity to increase the speed and quality
of future work.
** Unrealistic Expectations
If your users and stake holders are non-technical, like they often are, you will
inevitably come up against ridiculous expectations. "It will only take a couple
hours to add authorization, right?" If your application is well build and easy
to use, it might be indistinguishable from magic. That's a tribute to the great
work you've done.

So don't get frustrated by these requests. They are another chance for you to
connect with your users. This time, allow them to understand more about your
work. Compare the other features to the current features and explain why this
feature might take longer than another. 

Once the stake holders know the work required, they will give you more time or
pick a feature that they can have sooner. The important part is, you relieve
the pressure to rush and you educated the users so next time they know the scope
of this type of feature.
** The Right Tool for the Job
The notion of "the right tool for the job" echoes through every office.
Unfortunately, it's misunderstood almost as often as it gets uttered.

*Right* doesn't mean perfect. It means the tool that enables you to accomplish
the job without wasting your time. It even changes depending on the person or
the team.

If a team knows nothing about a language used to implement the perfect tool for
their use case, the cost may be too high. They could spend weeks learning how to
get to the solution. Where as if they use the language they know and add  
library that gets them 80% of the way there, they will accomplish the task with
a minor delay.

But keep in mind that every new tool brings challenges and considerations. Your
team has to learn the tool. You have to make sure the tool is maintained, or has
clean code so you could take on the maintenance. You have to verify that it
works well with the rest of your dependencies. If this sounds like too much
work, consider implementing your own version of the feature you need. 
** Limitations of Technology
This is the most surprising are of frustration for people. When you reach a
technological limitation -- like processing speed, memory limits, rendering
speed -- it's not time to dispaire. It's time to celebrate. You finally get to
dust off that old book on algorithms and pull out all the knowledge from your
degree, if you have one. 

These challenges don't come along too often for most of us. If you are lucky
enough to find one of these, dive in and enjoy what you will learn. 
